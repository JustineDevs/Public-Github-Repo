---
description: Solidity Smart Contract Clean Practices and Project Safety
globs:
  - "**/*.sol"
alwaysApply: true
---

# Solidity Code Implementation Techniques

- Use descriptive, intention-revealing names for variables, functions, and contracts.
- Avoid vague or misleading names to improve readability, auditability, and maintainability.
- Each function, contract, or library should have one clear, focused purpose (SRP).
- Express code intent clearly to minimize comments; document "why" decisions when necessary.
- Replace magic numbers and strings with named `constant` or `immutable` variables.
- Organize project using modules and interfaces; split logic into reusable components with imports.
- Favor code simplicity and clarity; avoid overly clever code constructs or gas-cost tradeoffs that risk security.
- Implement centralized and consistent error handling using `require`, `assert`, and custom error types.
- Follow Checks-Effects-Interactions pattern for state changes involving external calls to avoid reentrancy.
- Avoid arithmetic overflow/underflow; use built-in checked math or SafeMath for older Solidity versions.
- Use access control modifiers (`onlyOwner`, role-based access) and OpenZeppelin libraries for sensitive actions.
- Write and maintain robust unit/integration tests before deploying contracts; use TDD methodology.
- Prevent duplications by abstracting repeated logic into reusable libraries and utility contracts.
- Employ static analysis tools like Slither, MythX for vulnerability checks; resolve all high/critical issues before mainnet deployment.
- Regularly refactor code for simplicity and reduced technical debt.
- Do not use emoji, non-standard Unicode, or confusing ASCII art in contract code or comments.
- Use Solidity latest stable version unless required otherwise for compatibility.

# Avoiding Destructive Operations and Project Safety

- Restrict permissions for deployment, upgrade, and critical contract interactions; whitelist trusted addresses only.
- Use robust ownership and admin-control frameworks (Multi-sig, Timelock, etc.) for upgradeable contracts.
- Do not implement code capable of self-destructing essential contracts (`selfdestruct`) or erasing core data.
- Log and audit all sensitive administrative operations; events for changes and access attempts.
- Enable contract pausing and emergency stop mechanisms (e.g., `Pausable`) for incident response.
- Back up source code and deployment scripts using version control (Git) and off-chain secure storage.
- Do not deploy raw test or development contracts to mainnet; use safe release and auditing processes.
- Implement automated CI pipelines for build, test, and security validation steps; validate critical actions in pre-commit/checks.
- Use comprehensive audit trails for future project reviews.

# General Project Safety, Collaboration & Management

- Define clear roles, responsibilities, and access controls for all contributors, reviewers, and owners.
- Maintain high-quality documentation for contracts, ABI, deployment steps, and governance processes.
- Communicate security incidents, risk factors, and fixes effectively with the whole team.
- Foster regular code reviews, multi-party audits, and leverage community feedback where appropriate.
- Track high-impact bugs, confirmed vulnerabilities, upgrades, and rationale for all major changes.
- Use effective collaboration and communication platforms (Slack, Discord, etc.) to streamline development and incident response.
- Practice continuous improvement: conduct post-mortem/root-cause analysis after incidents and deployments.
# Summary of Auditing and Deployment Best Practices

- Prepare full documentation before each audit (contract code, architecture, goals).
- Run both automated and manual security tests; prioritize fixing critical and major issues.
- Publish comprehensive, transparent audit reports and changelogs after final deployment.
- Do not deploy contracts until all high-severity risks are addressed and tested on testnets.

# Solidity Naming Instructions

- Name every smart contract using PascalCase (e.g., TokenSale, VotingContract, RewardDistributor).
- Use descriptive names that convey the main functionality or responsibility of the contract—avoid vague or generic names like Contract1.
- The filename should match the main contract's name for clarity and discoverability (e.g., TokenSale.sol contains contract TokenSale).
- When including multiple contracts in a single file (not recommended), ensure the filename matches the core contract's name.
- Avoid abbreviations or single-letter names unless widely-accepted (such as ERC20).
- For test contracts, append Test to the contract being tested (e.g., ERC20Test).
- Library and struct names should also use PascalCase and be descriptive.

# Security Best Practices

- Use Latest Compiler Version: Always compile with the latest stable Solidity version to benefit from security patches and improved checks.
- Avoid Reentrancy Vulnerabilities: Apply the Checks-Effects-Interactions pattern. Use ReentrancyGuard from OpenZeppelin or manual mutexes to prevent reentrant calls.
- Restrict Access with Proper Modifiers: Use onlyOwner, onlyRole, or custom access controls to protect sensitive functions.
- Validate All Inputs: Use strict validation (require statements) for function parameters to prevent invalid data and unsafe states.
- Use Safe Math: For Solidity versions below 0.8, use SafeMath libraries for overflow/underflow protection; from 0.8+ native checked arithmetic is available.
- Minimize Contract Complexity: Keep contracts simple and focused to reduce attack surface and ease auditing.
- Implement Circuit Breakers: Use Pausable contracts that allow halting contract functions during emergency situations.
- Avoid Delegatecall with Untrusted Contracts: Delegatecall can lead to code execution in the caller context—only use with trusted contracts.
- Use Proper Randomness: Do not rely on block variables (block.timestamp, blockhash) for randomness. Use verified oracles or VRF services.
- Store Private Data Off-Chain: Do not store secrets or private keys on-chain as blockchain data is public.
- Limit Gas Consumption: Avoid unbounded loops or large state modifications that might run out of gas and cause failures.
- Write Comprehensive Tests: Cover edge cases and perform fuzz testing to catch unexpected scenarios.
- Static and Dynamic Analysis: Use tools like Slither, MythX, and Echidna to detect vulnerabilities before deployment.
- Audit and Review: Conduct manual audits with security experts and peer code reviews regularly.
- Use Upgradable Patterns Carefully: If using proxy contracts, ensure upgrade mechanisms have strict administrative control and transparent upgrade processes.
- Log All Critical Actions: Emit events for key state changes to maintain an audit trail.
- Avoid Using Deprecated Features: Do not use deprecated Solidity features or unsafe inline assembly.
- Implement Time Locks and Multisig: For admin operations, require time delay and multiple signatures to execute important transactions.